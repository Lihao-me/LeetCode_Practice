# 各位相加
***
#### 2020.01.26

### 问题
>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。

### 示例
>输入: 38
输出: 2 
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。

>进阶:
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？

### 思路
将整数的各数位相加，直到结果只剩一位数。

### 代码
```c
int addDigits(int num){
    int desperate(int n)
    {
        if(n<=9)
        return n;
        else
        return n%10+desperate(n/10); 
    }
    if(num<=9)
    return num;
    else
    return addDigits(desperate(num));
}
```

### 分析
 - 对于这道题首先想到的就是递归，开始的时候我就将“把整数各数位的数位相加”的功能赋予addDigits这一函数，但是该函数本身却并不易被赋予该功能，于是很容易
   想到再建一个函数来实现各数位相加的功能，而addDigits本身则可以进行递归与判断的操作，使外部的递归本身得以实现。
 - 值得说明的是，构建的计算函数也是一个递归函数，这就通过函数的嵌套让整个过程得以简化。从而也可以看到递归的妙处。
 - 但是题目最后的“进阶”对我却有点难度，如果不使用递归，很容易想到的就是循环。但当把这两种方法都排除后实在想不出还有什么办法。那今天的补充解法就贴上
   大神的非递归非循环代码吧。
   
```c
// 方法1：暴力法，需要两个循环，时间复杂度近似为 O(n^2)，n为num长度。
    int addDigits1(int num){
        int sum;
        while(num >= 10){
            sum = 0;
            while( num ){
                sum += num % 10;
                num /= 10;
            }
            num = sum;
        }
        return num;
    }

    // 方法2: 总结规律法。 时间复杂度为O(1)
    // 设三位数 n = 100a + 10b + c 则 n - ( a+b+c) = 99a + 9b 也就是说每次n的各位求和结果与原n相比，
    // 都减少了9的倍数（它俩的差是9的倍数），所以n对9取余的结果就是所求结果。
    // n为其他位数时等同，注意 n > 0 且 n % 9 == 0 时，结果应为9
    int addDigits2(int num){
        int res = num % 9;
        if( res == 0 && num > 0)
            return 9;
        else
            return res;
    }
}
作者：steve_stone
