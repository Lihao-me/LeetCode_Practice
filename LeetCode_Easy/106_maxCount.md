# 范围求和Ⅱ
***
#### 2020.07.10

### 问题
>给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。             
操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 <= i < a 以及 0 <= j < b 的元素 M[i][j] 的值都增加 1。                             
在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。                                              

### 示例
>输入:                       
m = 3, n = 3               
operations = [[2,2],[3,3]]                  
输出: 4                     
解释:                        
初始状态, M =                   
[[0, 0, 0],                     
 [0, 0, 0],              
 [0, 0, 0]]              
                                
执行完操作 [2,2] 后, M =                   
[[1, 1, 0],                 
 [1, 1, 0],                      
 [0, 0, 0]]                                     
                          
执行完操作 [3,3] 后, M =                   
[[2, 2, 1],                 
 [2, 2, 1],                     
 [1, 1, 1]]                      
M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。                        
                    
### 注意                    
>1.m 和 n 的范围是 [1,40000]。                    
2.a 的范围是 [1,m]，b 的范围是 [1,n]。                  
3.操作数目不超过 10000。           

### 代码
```c++
class Solution {
public:
    int maxCount(int m, int n, vector<vector<int>>& ops) {
        if(ops.empty()==1)
        return m*n;
        int a=m,b=n;
        for(auto op:ops)
        {
            a=min(a,op[0]);
            b=min(b,op[1]);
        }
        return a*b;
    }
};
```

### 分析
 - 执行用时：20 ms, 在所有 C++ 提交中击败了55.46%的用户内存消耗：10.8 MB, 在所有 C++ 提交中击败了100.00%的用户。
 - 这道题有一种似曾相识的感觉，我认为我们C语言的大学课程学习中是做过这道题的。但是当时的思想还是很简单，就老老实实创建一个m*n大小的二维数组，然后进行实地操作，但是现在来看这种方法是
   很笨拙的。而且高达10000的操作数目在时间消耗上是不允许我们这样暴力解决的。
 - 事实上当初在第一次做得时候就考虑到短板的效应关系。我们可以认为一次的操作就是向这个矩阵范围内加深一次，那么最后最深的那片区域所覆盖的元素数量就是我们要求的。而事实上一个循环就可以
   从矩阵的长宽上进行比较解决。步骤很简单也很好懂。在理解上主要碰到的一个小阻碍是很长时间没有接触二维数组类的题目，忘记了for(auto op:ops)实际是一层层访问每一行元素。不过从给出的操作
   矩阵是2行n列的也很好想。
 - 大家的题解做法与我相似，所以所谓的优解只是他们在使用上更为有技巧和熟练。
 
 ### 优解
 #### 8s范例
 ```c++
 class Solution {
public:
    int maxCount(int m, int n, vector<vector<int>>& ops) {
        int minx = INT_MAX, miny = INT_MAX;
        for (auto & v : ops) {
            minx = min(minx, v[0]);
            miny = min(miny, v[1]);
        }
        
        return minx != INT_MAX  ? minx * miny : m * n;
    }
};
```
