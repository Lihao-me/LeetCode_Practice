# 快乐数
***
#### 2020.01.28

### 问题
>编写一个算法来判断一个数是不是“快乐数”。
一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。
如果可以变为 1，那么这个数就是快乐数。

### 示例
>输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

### 代码
```c
bool isHappy(int n){
    int sqrt(int m)
    {
        return m*m;
    }
    int addSqrt(int x)
    {
        if(x<=9)
        return sqrt(x);
        else
        return sqrt(x%10)+addSqrt(x/10);
    }
    if(n==4)
    return 0;
    int y=addSqrt(n);
    if(y==1)
    return 1;
    else
    return isHappy(y);
}
```

### 分析
 - 这道题和之前做的分离整数的各数位并相加差不多，但难点就在于不是“快乐数”递归就可能无限进行下去，如何跳出递归是一个难题。
 - 看了网友的分析之后我也举了许多个数，然后得到了和网友一样的结论：如果是快乐数 最终会收敛到1， 如果不是快乐数 最终会出现4 16 37 58 89 145 42 20
   循环。所以再=在函数中加一个判断条件就迎刃而解啦。
 - 递归对于这道题应该是非常好的方法了，第一次在时间上击败100%的人还是有点小兴奋呀。但是内存上仅仅击败62.50%的人，看来代码上还是有可以优化的地方。
   然而这道题也不止递归和循环这两种，我也在网友的题解中了解到“快慢指针”这一算法。ps:快慢是指移动步数的长短，也就是每次向前移动速度的快慢。
   如，指定快指针每次沿着链表向前移动2步，指定慢指针每次沿着链表向前移动1步。快慢指针主要有两个应用：判断单链表是否为循环链表和有序链表中寻找中位数。
   具体了解应用看这个网站。https://blog.csdn.net/qq_21815981/article/details/79833976 目前了解还有点小深奥。贴上这个方法的代码。而且这位作者不建议
   使用递归，可能导致调用栈崩溃，那快慢指针可能就是最优的解法。
  
```c
方法：使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，
判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。
注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，
同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。
class Solution {
public:
    int bitSquareSum(int n) {
        int sum = 0;
        while(n > 0)
        {
            int bit = n % 10;
            sum += bit * bit;
            n = n / 10;
        }
        return sum;
    }
    
    bool isHappy(int n) {
        int slow = n, fast = n;
        do{
            slow = bitSquareSum(slow);
            fast = bitSquareSum(fast);
            fast = bitSquareSum(fast);
        }while(slow != fast);
        
        return slow == 1;
    }
};
作者：rachy
