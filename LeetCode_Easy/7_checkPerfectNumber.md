# 完美数
***

### 问题
>对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。
给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False

### 示例
>输入: 28
输出: True
解释: 28 = 1 + 2 + 4 + 7 + 14

>提示：
输入的数字 n 不会超过 100,000,000. (1e8)

### 代码
```c
bool checkPerfectNumber(int num){
    if(num%2!=0)
    return 0;
    else{
    int sum=1;
    for(int i=2;i*i<=num;i++)
    {
        if(num%i==0)
        sum=sum+(i+num/i);
    }
    if(sum==num)
    return 1;
    else
    return 0;
    }
}
```

### 分析
 - 这道题的思路还是很容易想到的，从1开始依次递增出现因数就参与相加，虽然题目限制了数字不会超过1e8，但第一次提交后我担心的事还是发生了，超出时间限制。
   思考很长时间未果后参考了网友的解答，发现了可以通过对整数开方的方式限制运行时间，这是从数学的角度采取的合适的方案。
 - 通过数学分析可以得知在枚举时，我们只需要从 1 到 sqrt(n) 进行枚举即可。这是因为如果 n 有一个大于 sqrt(n) 的因数 x，那么它一定有一个小于 sqrt(n)
   的因数 n/x。因此我们可以从 1 到 sqrt(n) 枚举 n 的因数，当出现一个 n 的因数 x 时，我们还需要算上 n/x。此外还需要考虑特殊情况，即 x = n/x，这时
   我们不能重复计算。也就是说sqrt(n)可以帮助我们找到它的一个“小因子”，那么另一个“大因子”就自然而然出现了，而不必再通过枚举的方法得到，大大缩短了时间。
 - 值得注意的是1不可能是“完美数”且奇数不可能是“完美数”，这更进一步缩短了运行的时间。从一开始的超出时间限制，到后来在时间上击败了100%的人，还是小有成就
   感呀。
 - 而题解官方则提供了另一种解法：欧几里得-欧拉定理，这就需要用上数学知识了，很难想了。
 
 ```java
 欧几里得-欧拉定理告诉我们，每个偶完全数都可以写成 2p−1(2p−1)2^{p-1}(2^p-1)2p−1(2p−1) 的形式，其中 ppp 为素数。
 例如前四个完全数可以写成如下形式：
6 = 2^1 * (2^2 - 1)
28 = 2^2 * (2^3 - 1)
496 = 2^3 * (2^4 - 1)
8128 = 2^4 * (2^5 - 1)

由于目前奇完全数还未被发现，因此所有的完全数都可以写成上述形式。当 n 不超过 10^8 时，p 也不会很大，因此我们只要带
入最小的若干个素数 2, 3, 5, 7, 13,17, 19, 31)，将不超过 10^8 的所有完全数计算出来即可。
Java
public class Solution {
    public int pn(int p) {
        return (1 << (p - 1)) * ((1 << p) - 1);
    }
    public boolean checkPerfectNumber(int num) {
        int[] primes=new int[]{2,3,5,7,13,17,19,31};
        for (int prime: primes) {
            if (pn(prime) == num)
                return true;
        }
        return false;
    }
}

作者：LeetCode
