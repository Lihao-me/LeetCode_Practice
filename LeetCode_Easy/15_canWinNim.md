# Nim游戏
***
#### 2020.02.06

### 问题
>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。
你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

### 示例
>输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。

### 代码
```c
bool canWinNim(int n){
    if(n%4==0)
    return 0;
    else
    return 1;
}
```

### 分析
 - 看到标签里的“脑筋急转弯”，我也是怀着好奇的心尝试了这一道。不要看这个代码简单，但对人脑的消耗却很大呀。题目本身还是非常有意思的。
 - 初看这道题首先举了几个例子进行尝试，1、2、3一定能保证我赢，4则是对方赢；5、6、7则总能让对方面对4的情况，即可以保证我赢，而8则只能让对方赢，以此类推，
   每四个石头一个循环，也就是说只要不是4的倍数我就能保证对方最后面对的是4，即对方输；若是4的倍数则我不能赢。这也用到了递推的思想。
 - 而我起初也是尝试用递推来实现编程的，但是很显然没有“倍数”的用法直接，所以中途也果断放弃。当然至于这一规律的严格的数学证明，还是由万能的网友用数学的归
   纳法帮助我证明了。
   
   证明：
   我们每次拿石头，一共有两种情况，A：石头总数为4的倍数，B：石头总数不为4的倍数，为什么我们会关注4的倍数呢。我们可以采取数学归纳法证明一下（证明对于4的
   倍数而言不管怎么拿都会得到还是4的倍数从8开始证明），就是因为对于4而言，谁面对4谁就输了，因为不管你拿1,2,3个剩下的都会被一次拿完，而对于2* 4=8个，面
   对8的时候不管拿x(1,2,3)个另一个人都可以4-x个使得剩下的为4个也就是输了（所以n=8时成立）。我们推广到4k数而言，当第一个人拿x（1,2,3）,第二个人就拿4-x
   所有得到了4k-x+(4-x) = 4*(k-1)也为4的倍数（所以当数为4k而言成立）;所以数学归纳法成立，所以对于任意4的倍数而言每次减小4最后都会得到4就代表着遇到4的
   倍数的人就输了，而对于情况B而言为什么就赢了呢？，因为对于一个不为4的倍数的值4* n>x>4* (n-1)，x处于两个4的倍数之间他们之差为4，由于x不为4的倍数，所
   以，x距离最近的4的倍数值最大为3，所以只要面对到不是4的倍数的值我们一定可以取走（1,2,3）中的某个值导致剩下的值为4的倍数，而面对4倍数的人一定输（已经
   证明）。所以我们只需要关注4的倍数的值即可。作者：heroine-yun
 - 要说还有什么更好的办法恐怕也没有了，但值得纳闷的是为什么我的代码时间和内存并不能击败100%呢？牛逼坏了的网友还有更高明的代码，实现了100%。把他的思路献
   上以供参考学习。而最后的代码中的bitset则是c++中的一个类库，类似于数组的结构，详细可见网页 https://www.cnblogs.com/magisk/p/8809922.html

```c
读了这道题， 我感觉有裴波那契数列内味了,后面的答案需要前面的结果嘛，
比如场上有5个石头,开局前我偷偷藏了一颗。这样下来，相当于场上只有4个石头，当你得意洋洋的取完最后一个石头的时候，这时~两级反转，
实则是我赢了。
所以我只需要看你在我前面的三位是否成功，只要你能成功那么这次我必能赢。具体的我去调试一下。

v1[i]=(v2[i-3]||v2[i-2]||v2[i-1]);
v2[i]=!v1[i]

上当了!上当了!上当了!出题人不当人啊！这么大的数肯定超时啊
你这个动态规划可真有够好笑的呢！起开!我来！你去把10以内的结果列出来看看
你发现没有，遇到4的倍数你都赢不了。
这也很理解，4就不用说了，我肯定赢。按照你刚才的理论，4+1,4+2,4+3，你都会赢。到了8因为我8-1,8-2,8-3都输了所以你在8处也会输。
如此反复,只消满足nums%4!=0你就肯定能赢。

class Solution {
public:
    bool canWinNim(int n) {
        return n%4;
    }
};

虽然AC了，性能不好，我来改改吧，这不就是求一个数是否是4的倍数吗,我们可以利用除法的截取下限来做
4ms 71,16%

class Solution {
public:
    bool canWinNim(int n) {
        int k=n>>2;
        return k<<2!=n;
    }
};

这么一操作我懂了，我们可以只看它二进制的后两位，只要是有1，就不是4的倍数
0ms 100%

class Solution {
public:
    bool canWinNim(int n) {
        bitset<32> b(n);
        return (b[0]==1||b[1]==1);
    }
};

作者：ooolize-2
