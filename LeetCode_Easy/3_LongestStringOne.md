# 最长特殊序列Ⅰ
***
#### 2020.01.25

### 问题
>给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。
子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。
输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。

### 示例
>输入: "aba", "cdc"
输出: 3
解析: 最长特殊序列可为 "aba" (或 "cdc")

>说明：
1.两个字符串长度均小于100。
2.字符串中的字符仅含有 'a'~'z'。

### 思路
>思考这道题应该分两种情况：1.两个字符串长度相同时，如果两个字符串相同则返回-1，如果两字符串不相同返回任一字符串长度即可；2.两个字符串不相同时，
返回最长的字符串长度即可。

### 代码
```c
int findLUSlength(char * a, char * b){
    if(strlen(a)==strlen(b))
    {
        if(strcmp(a,b)==0)
            return -1;
        else
        return strlen(a);
    }
    else
    {
        return strlen(a)>strlen(b)?strlen(a):strlen(b);
    }

}
```

### 分析
 - 这道题很容易想复杂。最初是很想把特殊序列一一提取再进行比较，即按题意进行比较分析，但很显然工作量非常大也很难操作。但是透过题目要求看到实质的东西，
   就可以发现从字符串长度入手会非常简单。
 - 同时学会使用与字符串有关的函数也非常重要。我也是在这里第一次使用到strcmp函数，涉及到字符串的比较，使用它就很方便了。ps：字符串比较函数，一般形式为strcmp(字符串1，字符串2)。
比较规则：
对两个字符串自左至右逐个字符相比（按ASCII码值大小比较），直到出现不同的字符或遇到‘\0’为止。如果全部字符相同，则认为相等；若出现不相同的字符，则以第一个不相同的字符的比较结果为准。
如果两个字符串都由英文字母组成，则有一个简单的规律：在英文字典中位置在后面的为“大”，还要特别注意：小写字母比大写字母“大”。
返回值：
（1）字符串1=字符串2，返回0
（2）字符串1>字符串2，返回一个正整数
（3）字符串1<字符串2，返回一个负整数。
 - 把题目抽丝剥茧后我以为可以击败很多人，然而并非如此。把一个C语言大神的代码贴上，仅仅一行也够我膜拜了。
 
 ```c
 int findLUSlength(char * a, char * b)
{
    return (strcmp(a, b) ? (strlen(a) > strlen(b) ? strlen(a) : strlen(b)) : -1);
}

作者：ljj666
