# 两整数之和
***
#### 2020.02.15

### 问题
>不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。

### 示例
>输入: a = 1, b = 2
输出: 3

>输入: a = -2, b = 3
输出: 1

### 思路
>正数减至0，另一数加相应的层数即为二者之和；负数加至0，另一数减相应的层数即为二者之和。

### 代码
```c++
class Solution {
public:
    int getSum(int a, int b) {
        if(a==0||b==0)
            return a!=0?a:b;
        else if(a>0){
            while(a!=0){
                a--;
                b++;
            }
            return b;
        }
        else if(a<0){
            while(a!=0){
            a++;
            b--;
            }
            return b;
        }
        return 0;
        
    }
};
```

### 分析
 - 看到这道题我首先想到的也是进位制运算，但是对二进制的异或运算和与运算的使用及原理掌握的不太熟练，所以首先选择了++/--运算。若有一为0，则返回另一数；
   若a为正数，则a逐一减至0，b逐一增加，b最终的数即为结果；若a为负数，则a逐一加至0，b逐一减少，b最终为结果。
 - 我的代码用时非常可怕2088ms，内存还好8.1MB。
 - 那么二进制的加法则是我学习的重点内容。
 
二进制的加法无外乎就以下几种情况，
1+1 = 0    （有进位）
1+0 = 1    （无进位）
0+0 = 0    （无进位）
0+1 = 1    （无进位）
仔细一看，在不考虑进位的情况下，这个不就是二进制的异或操作嘛。所以，我们就可以把加法分成无进位的异或结果，a^b  与保存的进位相加，循环直到没有进位为止，就可以得到结果了。
再分析二进制加法中进位怎么能保存，因为只有 1+1的时候会产生进位，这不就是与操作嘛，a&b   但是进位需要在更高的一位，所以我们就左移一位嘛就搞定了，
所以，进位就可以这样保存
c = (a&b)<<1;
这样就可以用  a = (a^b) ^ c 得到一轮结果 ，但是有可能还会有进位，所以需要将这个放在循环里面就可以了。
```c
 while (b)
    {
        auto carry = ((unsigned int ) (a & b))<<1 ; // 记录a+b的进位，直到进位为0是退出
        a = a^b;   //结果相加
        b = carry;  //循环
    }
    return a;
```
作者：zi-lun

```c++
 public class Solution {
    public int getSum(int a, int b) {
        int and = a & b; //与运算结果，1的位代表两个数值都为1，存在进位
        int eor = a ^ b; //异或运算结果，1的位代表两个数值对应位有一个为1

        //若and不为0，意味着存在进位情况，将进位左移
        if(and != 0) {
            and = and << 1;
        }

        //当进位为1的位数和有一位为1的位数相遇，与运算为1，证明再次存在进位运算
        while((and & eor) != 0){
            //计算新的进位
            int newAnd = and & eor;
            //再次比较出有一位为1的位数
            eor = and ^ eor;
            //把进位左移
            and = newAnd <<1;
        }
        //进位和有一位为1的位已经没有重叠，通过异或运算得出最终位数状态
        //为什么用抑或而不是或运算，因为之前应该进位的位没有改为0，
        //而该进的位已经写到最终的位置，因此原有两位都是1的值要通过抑或变为0
        return and ^ eor;
    }
}
作者：Hillyson
