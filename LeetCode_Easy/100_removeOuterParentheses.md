# 删除最外层的括号
***
#### 2020.07.04

### 问题
>有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。                
如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。                     
给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。                        
对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。                                 

### 示例
>输入："(()())(())"                    
输出："()()()"                 
解释：                              
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，                
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。                          

>输入："(()())(())(()(()))"                   
输出："()()()()(())"                 
解释：                              
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，                
删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。                           

>输入："()()"               
输出：""                              
解释：              
输入字符串为 "()()"，原语化分解得到 "()" + "()"，              
删除每个部分中的最外层括号后得到 "" + "" = ""。                                        

### 提示
>1.S.length <= 10000                    
2.S[i] 为 "(" 或 ")"                
3.S 是一个有效括号字符串                                               

### 代码
```c++
class Solution {
public:
    string removeOuterParentheses(string S) {
        stack<char>s;
        string res="";
        for(int i=0,j=0;i<S.size();i++)
        {
            if(S[i]=='(')
            s.push('(');
            else
            s.pop();
            if(s.size()==0)
            {
                res+=S.substr(j+1,i-j-1);
                j=i+1;
            }

        }
        return res;
    }
};
```

### 分析
 - 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户内存消耗：6.9 MB, 在所有 C++ 提交中击败了100.00%的用户。
 - 本题很容易联想到之前做过的括号匹配问题，而对于这类问题，运用“栈”的思路很容易解决。本来做这道题的时候也是很乱，首先考虑的是括号位置的数学规律进行解决，但很显然它的规律是很难用计算机
   进行计算和模拟的。
 - 而联想到之前的括号匹配问题，想到了栈，但是如何运用是一个问题。于是参考了网友的思路，其实和括号匹配问题一样，“是否将压入栈的元素全部弹出”是判断一个“原语”是否出现的关键。另一个关键就
   是找到两个指针的位置和关系，体现了一定的数学规律，也比较难控制。
 - 而网友中另一种更多的解法是找到一段“完整”的原语然后删掉最外层，我认为这种类似于双指针的思想和我的解法的本质想法是一致的。然而使用栈则似乎更为方便一些。
   
### 优解
#### 左括号数量等于右括号
```c++
class Solution {
public:
    string removeOuterParentheses(string S) {
        int L=1;int R=0;
        string ans;
        for(int i=1;i<S.size();i++){
            if(S[i]=='(')L++;
            else R++;
            if(R!=L)ans.push_back(S[i]);
            else {
                i++;L=1;R=0;
            }
        }
        return ans;
    }
};

作者：lygin
链接：https://leetcode-cn.com/problems/remove-outermost-parentheses/solution/c100jie-fa-by-lygin/
```
