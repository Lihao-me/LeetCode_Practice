# 盛最多水的容器
***
#### 2020.03.11

### 问题
>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，
垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。
[图片](https://github.com/Lihao-me/Pictures/blob/master/maxArea.jpg)   
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

### 示例
>输入：[1,8,6,2,5,4,8,3,7]    
输出：49

### 代码
```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i=0,j=height.size()-1;
        int res=0;
        while(i<j){
            int squ=(j-i)*min(height[i],height[j]);
            res=max(res,squ);
            if(height[i]<height[j])
            i++;
            else
            j--;
        }
        return res;
    }
};
```

### 分析
 - 执行用时 :20 ms, 在所有 C++ 提交中击败了63.63%的用户内存消耗 :15.1 MB, 在所有 C++ 提交中击败了5.06%的用户。这道题看起来比较容易，但是实践起来却
   比较困难。我一开始也想到用双指针来做，但实在想不明白怎么操纵来实现比较。也是看了网友的说明之后稍稍了解。其实和短板效应差不多，水的高度只能跟最短的
   板齐平。通过判断，记录当前的面积，如果左边的板比右边短，则左边往后寻找更长的板，右边的同理亦然。
 - 一位网友的解释非常的清晰，同时还可以通过贪心算法提高速度。
 
这道题目看似简单，做起来才发现不容易。分治法、动态规划都用不上，要想得到 O(n)O(n)O(n) 的解法只有使用双指针一条路。即使看了答案知道了双指针解法，
你也可能并不清楚这个解法为什么正确。为什么双指针往中间移动时，不会漏掉某些情况呢？如果没有真正理解题目，即使一次对着答案做出来了，再次遇到这个题目，
还是可能做不出来。要理解这道题的正确性和原理，需要从背后的缩减搜索空间的思想去考虑题解。下面我将用图片解释这道题的正确性和原理。
用一句话概括双指针解法的要点：指针每一次移动，都意味着排除掉了一个柱子。
如下图所示，在一开始，我们考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离 d=8d = 8d=8；水的高度取决于两根柱子之间较短的那个，
即左边柱子的高度 h=3h = 3h=3。水的面积就是 3×8=243 \times 8 = 243×8=24。
如果选择固定一根柱子，另外一根变化，水的面积会有什么变化吗？稍加思考可得：
当前柱子是最两侧的柱子，水的宽度 ddd 为最大，其他的组合，水的宽度都比这个小。
左边柱子较短，决定了水的高度为 3。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。
如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 3，也就是不会超过现在的水面高度。
由此可见，如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子
的组合，其实都可以排除了。也就是我们可以排除掉左边的柱子了。这个排除掉左边柱子的操作，就是双指针代码里的 i++。i 和 j 两个指针中间的区域都是还未排除
掉的区域。随着不断的排除，i 和 j 都会往中间移动。当 i 和 j相遇，算法就结束了。

作者：nettee

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        // st 为头指针，en 为尾指针
        int st = 0, en = height.size() - 1;
        // stlas 与 enlas 分别存储 st 与 en 指向的“当前值”
        int stlas, enlas;
        // ans 初始化
        int ans = min(height[st], height[en]) * (en - st);
        while(st < en)
        {
            // 外层 while 控制两指针交替移动
            while(height[st] <= height[en] && st < en)
            {
                stlas = height[st];
                st ++;
                // 内层 while 控制头指针寻找下一个 “值” 大于 “当前值 stlas” 的位置
                while(height[st] <= stlas && st < en) st ++;
                ans = max(ans, min(height[st], height[en]) * (en - st));
            }
            while(height[st] >= height[en] && st < en)
            {
                enlas = height[en];
                en --;
                // 内层 while 控制尾指针寻找下一个 “值” 大于 “当前值 enlas” 的位置
                while(height[en] <= enlas && st < en) en --;
                ans = max(ans, min(height[st], height[en]) * (en - st));
            }
        }
        return ans;
    }
};

作者：iswJXkYVv3
