# 飞机座位分配概率
***
#### 2020.02.10

### 问题
>有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。
剩下的乘客将会：	
	如果他们自己的座位还空着，就坐到自己的座位上，
	当他们自己的座位被占用时，随机选择其他座位
第 n 位乘客坐在自己的座位上的概率是多少？

### 示例
>输入：n = 1
输出：1.00000
解释：第一个人只会坐在自己的位置上。

>输入: n = 2
输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。

>提示：
1 <= n <= 10^5

### 代码
```c
double nthPersonGetsNthSeat(int n){
    if(n==1)
    return 1;
    else
    return (1.0/n+((n-2.0)/n)*nthPersonGetsNthSeat(n-1));
}
```

### 分析
 - 这依然是一道冠以“脑筋急转弯”标签的题，但我觉得更应该说是一道数学问题。我也是冥思苦想了好久。尝试了好多组数据发现除1以外其他数据的结果都是0.5。
   至于详细的数学归纳并推理证明如下：
   假设共有n个座位，令f(i)表示第一个人选择第i个人的座位时，第n个座位被其他人（1到n-1）占用的概率.
   显然f(n)=1，即如果第一个人选择第n个座位，那么第n个座位必然是被其他占用了。
   f(n-1)=1/2，即如果1选择n-1，则2到n-2会对号入座，第n-1个人选择的时候有两种选择（1和n），选n的概率为1/2。
   f(n-2)=1/3+1/3f(n-1)=1/2，即如果第一个人选择第n-2个座位，那么第n-2个人有三种选择（1，n-1，n），每个都是1/3。如果选择n，那么概率为1/3；如果选择
   n-1座位，则第n-1个人做选择时，和第1个人选择n-1情况是一样的，即f(n-1)。
   以此类推：
   f(n-3)=1/4+1/4f(n-1)+1/4f(n-2)=1/2
   ...
   ...
   ...
   f(2)=1/2
   f(1)=0
   因此第n个座位被其他人占用的概率为1/n[f(2)+f(3)+...+f(n)]=1/2。
 - 但很显然这样直接返回0.5并不符合编程的本意，我们更应该让更多的工作交给计算机。所以另一个网友的递归思路给了我很大启发，我们考虑n个人可以分3种情况，剩
   下的继续考虑n-1个人。网友把思路也整理得很好，摘抄如下：给n位乘客编号，1号乘客的座位号为1，如此类推。不妨假设按乘客编号顺序入座。
   1号乘客忘记了自己的座位号，所以他准备随机入座。将出现三种情况。情况一，1号乘客恰好坐到了1号座位，后续乘客将陆续入座，仿佛什么也没有发生；情况二，1号
   乘客恰好坐到了n号座位，接下来除了倒霉的n号乘客，大家都坐到了自己的座位上，n号乘客灰溜溜地坐到了1号座位；情况三，1号乘客既没有坐到1号座位，也没有坐到
   n号座位，而是坐到了2号座位（也可以是3号等等，但为了方便描述和喜剧效果，假定1号乘客坐到的位置就是2号），可以预见，接下来会出大乱了。
   上述情形中，情况一和情况二出现的概率均为1/n，情况三出现的概率为(n-2)/n。
   轮到2号乘客选座。其实，此时的情况与刚刚的情况是完全一样的。如果2号乘客坐到了1号座位，将不存在后续的混乱，此时不妨假设原1号座位就是2号乘客的，那么接
   下来的分析将与上述情形相同。为了便于理解，可以重新编号，原n号乘客变为n-1号，原2号乘客变为1号，其他乘客可以随便编排，当然，座位号也需要重新编排，从1
   号到n-1号，与乘客编号一一对应。作者：bevischou。！[图片](https://github.com/Lihao-me/Pictures/blob/master/nthPersonGetsNthSeat.png)
 - 如果说递归不太好理解的话，网友还提供了动态规划的解法，而其思路也有递推的思想，但是由于动态规划的使用不会造成超时的问题。递归在时间和内存上都不太理想
   当然是不及直接返回，动态规划也是如此。
```c++
   // 用“乘客i”表示第i位乘客，他自己的座位表示为“座位i”， 1<=i<=n；
// 那么乘客n坐在座位n的前提条件是，乘客1~(n-2)都坐在自己的位置上
// 乘客1面临3种选择：
// 1.坐在座位1，那么从第k+1位乘客开始都能坐在自己的座位上，第n位乘客自然可以坐在自己的座位；
// 2.坐在座位n，那么第n位乘客肯定不能坐在自己的座位；
// 3.在座位2~(n-1)中随机挑选一个座位i，那么乘客i就面临随机挑选座位的问题，问题简化为
// 有一位乘客要随机挑座而最后一位乘客坐在自己的座位上的概率，这与是否为乘客1无关，问题规模
// 变成(n-1)
// 假设每位乘客挑选每个座位的概率都是一样的，即为 1/i
// 所以状态转移方程为: dp[i] = 1/i1 + 1/i0 + (i-2)/i*dp[i-1]
#define MAX_N 100001
double nthPersonGetsNthSeat(int n)
{
    if (n <= 0) {
        return 0.0;
    }

    double dp[MAX_N] = {0.0};

    dp[1] = 1.0;

    for (int i = 2; i <= n; i++) {
        dp[i] = 1.0 / i + 1.0 * (i - 2) / i * dp[i - 1];    // 1.0用于转换为浮点数
    }

    return dp[n];
}

作者：little_bee
